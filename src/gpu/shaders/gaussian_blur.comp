#version 430

layout(local_size_x = 256) in;

layout(std430, binding = 0) buffer InputBuffer {
    float input_heights[];
};

layout(std430, binding = 1) buffer OutputBuffer {
    float output_heights[];
};

uniform int width;
uniform int height;
uniform int radius;
uniform bool horizontal;  // true for horizontal pass, false for vertical

// Shared memory for coalesced reads
shared float cache[256 + 32];  // Work group size + 2*max_radius

// Gaussian weights (precomputed on CPU, passed as uniform)
uniform float weights[17];  // Support up to radius 8

void main() {
    uint gid = gl_GlobalInvocationID.x;
    uint lid = gl_LocalInvocationID.x;

    if (horizontal) {
        // Horizontal blur
        uint y = gid / uint(width);
        uint x = gid % uint(width);

        if (y >= uint(height)) return;

        // Load data into shared memory with halos
        int baseX = int(x) - radius;
        cache[lid] = (baseX >= 0 && baseX < width) ?
            input_heights[y * uint(width) + uint(baseX)] : 0.0;

        // Load right halo
        if (lid < uint(radius * 2)) {
            int haloX = int(x) + int(lid) + 1;
            uint haloIdx = lid + 256;
            cache[haloIdx] = (haloX >= 0 && haloX < width) ?
                input_heights[y * uint(width) + uint(haloX)] : 0.0;
        }

        barrier();

        // Apply blur
        float sum = 0.0;
        float weightSum = 0.0;

        for (int i = -radius; i <= radius; i++) {
            int sampleX = int(x) + i;
            if (sampleX >= 0 && sampleX < width) {
                float weight = weights[i + radius];
                sum += cache[lid + uint(i + radius)] * weight;
                weightSum += weight;
            }
        }

        output_heights[gid] = (weightSum > 0.0) ? (sum / weightSum) : input_heights[gid];

    } else {
        // Vertical blur
        uint x = gid % uint(width);
        uint y = gid / uint(width);

        if (y >= uint(height)) return;

        // Vertical blur is less efficient due to non-coalesced access
        // Direct computation without shared memory
        float sum = 0.0;
        float weightSum = 0.0;

        for (int i = -radius; i <= radius; i++) {
            int sampleY = int(y) + i;
            if (sampleY >= 0 && sampleY < height) {
                float weight = weights[i + radius];
                uint idx = uint(sampleY) * uint(width) + x;
                sum += input_heights[idx] * weight;
                weightSum += weight;
            }
        }

        output_heights[gid] = (weightSum > 0.0) ? (sum / weightSum) : input_heights[gid];
    }
}
